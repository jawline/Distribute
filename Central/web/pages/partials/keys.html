<div class="container">
    <div class="small-gap panel panel-default">
        <div class="panel-body">
        <h2>
        Key Management
		</h2>
            <hr class="featurette-divider">
            <div>
                <p>

Cryptographic methods are of very little use if the private keys needed in the method cannot be kept secure. Indeed, poor key management protocols often present some of the most easily exploitable vulnerabilities in a cryptographic primitive. In practice, a key management system that is resistant to all possible attacks is a difficult thing to create and implement; the process requires many controls and regulations and is not absolute. Some of the main goals that a key management system must seek to satisfy are as follows:</p><p>

Secrecy: Throughout the whole system, private keys must remain secret from all unauthorised parties.  This has ramifications to the security of the whole key management system; from the initial generation of the keys to the movements and usages of the keys to the physical devices on which they are hosted.  Even the archiving or destruction of expired keys must be carefully considered.</p><p>

Assurance of Purpose: The key has to be appropriate for its desired function. This means that is must be a suitable key for the encryption algorithm it is used for (length of the key is an implication here too) and restricted in usage so that it not used for other purposes. Using a key for the wrong purpose can be very damaging. (Note that Assurance of Purpose is a more pressing concern in public key management systems than private ones.)</p><p>

In addition to these primary goals, there are many other variables that a key management system may depend on. Key generation is not a trivial task- it is important that the key is generated by either non-deterministic (such as measurement of radioactive decay time intervals) or deterministic (such as an algorithm producing output from a seed that appears random) means.  The former method is more expensive but more secure, whilst the latter method is faster and cheaper, but less secure, in the sense that information could potentially be gleaned from the ciphertext about the key, and the seed used for generation must be kept secret. A common approach is to derive many additional keys from one randomly generated base key.  </p><p>

<img class="maxfill" src="./img/dilb.png"/>[1]
</p><p>
Key hierarchies are also commonly used, where keys at higher levels are used to encrypt keys at lower level. This is very useful in large network topologies, where many keys are needed. Higher level keys are expensive to establish and often require additional security, but their inclusion makes it much easier to secure and store lower level keys, and low level-keys can be changed without needing to change higher level keys. Key storage, particularly of high level keys, is a delicate matter. The safest places to store high level keys is in dedicated hardware designed solely for the purpose. These are normally called Hardware Security Modules. Whilst offering physical protection, these devices can also exhibit different forms of tamper resistance, including movement sensors, micro-switches, temperature detectors and resin.</p><p>
<img class="maxfill" src="./img/mkey.png"/>[2]
</p><p>
<b>Unique key per transaction (UKPT) schemes</b></p><p>
UKPT schemes solve some of the problems of key storage by eliminating the need for key storage entirely. Instead, a new key is generated for each use. Retail point-of-sale terminals represent a salient example of UKPT schemes. A new key is generated for each use by a key derivation process. This is done through the use of a key register, which updates after every transaction to generate a new key. The initial value of a register is a secret seed known both by the merchant and the terminal. Provided the host also maintains an identical key register to the one used by the terminal, both parties always have access to the private key for each transaction, and can encrypt and decrypt appropriately.
</p><p>
<b>Public key management systems</b></p><p>
All of the issues discussed above for apply to both public and private key management systems, but public key systems also have other concerns that revolve around the need to provide assurance of purpose. Essentially, this revolves around being able to verify that the public key used to sign a message actually belongs to the sender of the message. The main approach to verifying this is to use Public-Key certificates. These certificates bind a public key to data that provides assurance of purpose for that public key (this data normally consists of items such as a digital signature, a name, a timestamp etc). The creator of this certificate is known as a Certificate Authority (CA). The CA is a trusted third party, which generates many new other issues that need to be considered regarding trust.</p><p>
<img class="maxfill" src="./img/circle.png"/>[3]
</p><p>
<b>[1]</b> <a href="http://williamstallings.com/Cryptography/Crypto6e-Student/">http://williamstallings.com/Cryptography/Crypto6e-Student/</a></p><p>
<b>[2]</b> <a href="https://blogs.aws.amazon.com/security/blog/tag/Encryption">https://blogs.aws.amazon.com/security/blog/tag/Encryption</a></p><p>
<b>[3]</b> <a href="http://www.secureconsulting.net/2008/03/the_key_management_lifecycle_1.html">http://www.secureconsulting.net/2008/03/the_key_management_lifecycle_1.html</a></p><p>
 </p>
            </div>
        </div>
    </div>
</div>